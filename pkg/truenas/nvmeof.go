package truenas

import (
	"context"
	"fmt"
	"net"
	"strings"
)

// NVMeoFSubsystem represents an NVMe-oF subsystem from the TrueNAS API.
// Updated for TrueNAS SCALE 25.10+ API changes.
type NVMeoFSubsystem struct {
	ID           int    `json:"id"`
	Name         string `json:"name"`          // Human readable name (25.10+)
	NQN          string `json:"subnqn"`        // NVMe Qualified Name (was "nqn" pre-25.10)
	Serial       string `json:"serial"`        // Auto-generated in 25.10+
	AllowAnyHost bool   `json:"allow_any_host"`
	Hosts        []int  `json:"hosts"`         // Host IDs (changed from []string in 25.10)
	Namespaces   []int  `json:"namespaces"`
	Ports        []int  `json:"ports"`         // Port IDs (new in 25.10)
}

// NVMeoFNamespace represents an NVMe-oF namespace from the TrueNAS API.
// Updated for TrueNAS SCALE 25.10+ API changes.
type NVMeoFNamespace struct {
	ID          int    `json:"id"`
	SubsystemID int    // Extracted from subsys.id (was "subsystem" int pre-25.10)
	NSID        int    `json:"nsid"`
	DeviceType  string `json:"device_type"`  // "ZVOL" or "FILE" (new in 25.10)
	DevicePath  string `json:"device_path"`  // Format: "zvol/pool/vol" (was "/dev/zvol/..." pre-25.10)
	DeviceUUID  string `json:"device_uuid"`  // New in 25.10
	DeviceNGUID string `json:"device_nguid"` // New in 25.10
	Enabled     bool   `json:"enabled"`
	Locked      bool   `json:"locked"` // New in 25.10
}

// NVMeoFPort represents an NVMe-oF port from the TrueNAS API.
// Updated for TrueNAS SCALE 25.10+ API changes.
type NVMeoFPort struct {
	ID         int    `json:"id"`
	Index      int    `json:"index"`         // New in 25.10
	Transport  string `json:"addr_trtype"`   // Was "transport" pre-25.10
	Address    string `json:"addr_traddr"`
	Port       int    `json:"addr_trsvcid"`
	AddrFamily string `json:"addr_adrfam"`   // New in 25.10: "IPV4", "IPV6", "FC"
	Enabled    bool   `json:"enabled"`       // New in 25.10
	Subsystems []int  `json:"subsystems"`
}

// NVMeoFSubsystemCreate creates a new NVMe-oF subsystem.
// Updated for TrueNAS SCALE 25.10+: uses "name" parameter instead of "nqn",
// and serial is auto-generated by TrueNAS.
func (c *Client) NVMeoFSubsystemCreate(ctx context.Context, name string, allowAnyHost bool, hostIDs []int) (*NVMeoFSubsystem, error) {
	params := map[string]interface{}{
		"name":           name,
		"allow_any_host": allowAnyHost,
	}
	// Note: In 25.10+, hosts are referenced by ID, not NQN string
	// Host IDs must be created first via nvmet.host.create if access control is needed

	result, err := c.Call(ctx, "nvmet.subsys.create", params)
	if err != nil {
		if strings.Contains(err.Error(), "already exists") {
			return c.NVMeoFSubsystemFindByName(ctx, name)
		}
		return nil, fmt.Errorf("failed to create NVMe-oF subsystem: %w", err)
	}

	return parseNVMeoFSubsystem(result)
}

// NVMeoFSubsystemDelete deletes an NVMe-oF subsystem.
func (c *Client) NVMeoFSubsystemDelete(ctx context.Context, id int) error {
	_, err := c.Call(ctx, "nvmet.subsys.delete", id)
	if err != nil {
		if strings.Contains(err.Error(), "does not exist") ||
			strings.Contains(err.Error(), "not found") {
			return nil
		}
		return fmt.Errorf("failed to delete NVMe-oF subsystem: %w", err)
	}
	return nil
}

// NVMeoFSubsystemGet retrieves an NVMe-oF subsystem by ID.
func (c *Client) NVMeoFSubsystemGet(ctx context.Context, id int) (*NVMeoFSubsystem, error) {
	filters := [][]interface{}{{"id", "=", id}}
	result, err := c.Call(ctx, "nvmet.subsys.query", filters, map[string]interface{}{})
	if err != nil {
		return nil, fmt.Errorf("failed to get NVMe-oF subsystem: %w", err)
	}

	subsystems, ok := result.([]interface{})
	if !ok || len(subsystems) == 0 {
		return nil, fmt.Errorf("NVMe-oF subsystem not found: %d", id)
	}

	return parseNVMeoFSubsystem(subsystems[0])
}

// NVMeoFSubsystemFindByNQN finds an NVMe-oF subsystem by NQN (subnqn in 25.10+).
func (c *Client) NVMeoFSubsystemFindByNQN(ctx context.Context, nqn string) (*NVMeoFSubsystem, error) {
	// In 25.10+, the field is "subnqn" instead of "nqn"
	filters := [][]interface{}{{"subnqn", "=", nqn}}
	result, err := c.Call(ctx, "nvmet.subsys.query", filters, map[string]interface{}{})
	if err != nil {
		return nil, fmt.Errorf("failed to query NVMe-oF subsystems: %w", err)
	}

	subsystems, ok := result.([]interface{})
	if !ok || len(subsystems) == 0 {
		return nil, nil
	}

	return parseNVMeoFSubsystem(subsystems[0])
}

// NVMeoFSubsystemFindByName finds an NVMe-oF subsystem by name (25.10+).
func (c *Client) NVMeoFSubsystemFindByName(ctx context.Context, name string) (*NVMeoFSubsystem, error) {
	filters := [][]interface{}{{"name", "=", name}}
	result, err := c.Call(ctx, "nvmet.subsys.query", filters, map[string]interface{}{})
	if err != nil {
		return nil, fmt.Errorf("failed to query NVMe-oF subsystems: %w", err)
	}

	subsystems, ok := result.([]interface{})
	if !ok || len(subsystems) == 0 {
		return nil, nil
	}

	return parseNVMeoFSubsystem(subsystems[0])
}

// NVMeoFNamespaceCreate creates a new NVMe-oF namespace.
// Updated for TrueNAS SCALE 25.10+: uses "subsys_id" and requires "device_type".
// devicePath should be in format "zvol/pool/volume" (without /dev/ prefix).
func (c *Client) NVMeoFNamespaceCreate(ctx context.Context, subsystemID int, devicePath string, deviceType string) (*NVMeoFNamespace, error) {
	// Normalize device path: strip /dev/ prefix if present (pre-25.10 format)
	normalizedPath := devicePath
	if strings.HasPrefix(devicePath, "/dev/") {
		normalizedPath = strings.TrimPrefix(devicePath, "/dev/")
	}

	// Default to ZVOL if not specified
	if deviceType == "" {
		deviceType = "ZVOL"
	}

	params := map[string]interface{}{
		"subsys_id":   subsystemID, // Changed from "subsystem" in 25.10
		"device_type": deviceType,  // New required field in 25.10
		"device_path": normalizedPath,
	}

	result, err := c.Call(ctx, "nvmet.namespace.create", params)
	if err != nil {
		if strings.Contains(err.Error(), "already exists") {
			return c.NVMeoFNamespaceFindByDevice(ctx, subsystemID, normalizedPath)
		}
		return nil, fmt.Errorf("failed to create NVMe-oF namespace: %w", err)
	}

	return parseNVMeoFNamespace(result)
}

// NVMeoFNamespaceDelete deletes an NVMe-oF namespace.
func (c *Client) NVMeoFNamespaceDelete(ctx context.Context, id int) error {
	_, err := c.Call(ctx, "nvmet.namespace.delete", id)
	if err != nil {
		if strings.Contains(err.Error(), "does not exist") ||
			strings.Contains(err.Error(), "not found") {
			return nil
		}
		return fmt.Errorf("failed to delete NVMe-oF namespace: %w", err)
	}
	return nil
}

// NVMeoFNamespaceGet retrieves an NVMe-oF namespace by ID.
func (c *Client) NVMeoFNamespaceGet(ctx context.Context, id int) (*NVMeoFNamespace, error) {
	filters := [][]interface{}{{"id", "=", id}}
	result, err := c.Call(ctx, "nvmet.namespace.query", filters, map[string]interface{}{})
	if err != nil {
		return nil, fmt.Errorf("failed to get NVMe-oF namespace: %w", err)
	}

	namespaces, ok := result.([]interface{})
	if !ok || len(namespaces) == 0 {
		return nil, fmt.Errorf("NVMe-oF namespace not found: %d", id)
	}

	return parseNVMeoFNamespace(namespaces[0])
}

// NVMeoFNamespaceFindByDevice finds an NVMe-oF namespace by device path.
// Updated for TrueNAS SCALE 25.10+: uses "subsys.id" instead of "subsystem".
func (c *Client) NVMeoFNamespaceFindByDevice(ctx context.Context, subsystemID int, devicePath string) (*NVMeoFNamespace, error) {
	// Normalize device path: strip /dev/ prefix if present
	normalizedPath := devicePath
	if strings.HasPrefix(devicePath, "/dev/") {
		normalizedPath = strings.TrimPrefix(devicePath, "/dev/")
	}

	filters := [][]interface{}{
		{"subsys.id", "=", subsystemID}, // Changed from "subsystem" in 25.10
		{"device_path", "=", normalizedPath},
	}
	result, err := c.Call(ctx, "nvmet.namespace.query", filters, map[string]interface{}{})
	if err != nil {
		return nil, fmt.Errorf("failed to query NVMe-oF namespaces: %w", err)
	}

	namespaces, ok := result.([]interface{})
	if !ok || len(namespaces) == 0 {
		return nil, nil
	}

	return parseNVMeoFNamespace(namespaces[0])
}

// NVMeoFNamespaceFindByDevicePath finds an NVMe-oF namespace by device path across all subsystems.
// This is useful for checking if any namespace references a given zvol.
// Updated for TrueNAS SCALE 25.10+: normalizes device path format.
func (c *Client) NVMeoFNamespaceFindByDevicePath(ctx context.Context, devicePath string) (*NVMeoFNamespace, error) {
	// Normalize device path: strip /dev/ prefix if present
	normalizedPath := devicePath
	if strings.HasPrefix(devicePath, "/dev/") {
		normalizedPath = strings.TrimPrefix(devicePath, "/dev/")
	}

	filters := [][]interface{}{
		{"device_path", "=", normalizedPath},
	}
	result, err := c.Call(ctx, "nvmet.namespace.query", filters, map[string]interface{}{})
	if err != nil {
		return nil, fmt.Errorf("failed to query NVMe-oF namespaces: %w", err)
	}

	namespaces, ok := result.([]interface{})
	if !ok || len(namespaces) == 0 {
		return nil, nil
	}

	return parseNVMeoFNamespace(namespaces[0])
}

// NVMeoFPortList lists all NVMe-oF ports.
func (c *Client) NVMeoFPortList(ctx context.Context) ([]*NVMeoFPort, error) {
	result, err := c.Call(ctx, "nvmet.port.query", []interface{}{}, map[string]interface{}{})
	if err != nil {
		return nil, fmt.Errorf("failed to list NVMe-oF ports: %w", err)
	}

	items, ok := result.([]interface{})
	if !ok {
		return nil, fmt.Errorf("unexpected response format")
	}

	ports := make([]*NVMeoFPort, 0, len(items))
	for _, item := range items {
		port, err := parseNVMeoFPort(item)
		if err != nil {
			continue
		}
		ports = append(ports, port)
	}

	return ports, nil
}

// NVMeoFPortCreate creates a new NVMe-oF port.
// Updated for TrueNAS SCALE 25.10+: uses addr_trtype, addr_traddr, addr_trsvcid.
// Note: addr_adrfam is auto-detected by TrueNAS and should not be passed on create.
func (c *Client) NVMeoFPortCreate(ctx context.Context, transport string, address string, port int) (*NVMeoFPort, error) {
	params := map[string]interface{}{
		"addr_trtype":  strings.ToUpper(transport),
		"addr_traddr":  address,
		"addr_trsvcid": port,
	}

	result, err := c.Call(ctx, "nvmet.port.create", params)
	if err != nil {
		if strings.Contains(err.Error(), "already exists") {
			return c.NVMeoFPortFindByAddress(ctx, transport, address, port)
		}
		return nil, fmt.Errorf("failed to create NVMe-oF port: %w", err)
	}

	return parseNVMeoFPort(result)
}

// NVMeoFPortFindByAddress finds an NVMe-oF port by transport, address, and port.
func (c *Client) NVMeoFPortFindByAddress(ctx context.Context, transport string, address string, port int) (*NVMeoFPort, error) {
	filters := [][]interface{}{
		{"addr_trtype", "=", strings.ToUpper(transport)},
		{"addr_traddr", "=", address},
		{"addr_trsvcid", "=", port},
	}
	result, err := c.Call(ctx, "nvmet.port.query", filters, map[string]interface{}{})
	if err != nil {
		return nil, fmt.Errorf("failed to query NVMe-oF ports: %w", err)
	}

	ports, ok := result.([]interface{})
	if !ok || len(ports) == 0 {
		return nil, nil
	}

	return parseNVMeoFPort(ports[0])
}

// NVMeoFPortSubsysCreate creates an association between a port and a subsystem.
// This makes the subsystem accessible on that port.
// Updated for TrueNAS SCALE 25.10+: uses nvmet.port_subsys.create API.
func (c *Client) NVMeoFPortSubsysCreate(ctx context.Context, portID int, subsysID int) error {
	params := map[string]interface{}{
		"port_id":   portID,
		"subsys_id": subsysID,
	}

	_, err := c.Call(ctx, "nvmet.port_subsys.create", params)
	if err != nil {
		if strings.Contains(err.Error(), "already exists") {
			return nil // Association already exists, that's fine
		}
		return fmt.Errorf("failed to create port-subsystem association: %w", err)
	}

	return nil
}

// NVMeoFPortSubsysFindBySubsystem checks if a subsystem is already associated with any port.
// Note: TrueNAS 25.10+ API doesn't support filtering by nested fields (subsys.id),
// so we fetch all associations and filter client-side.
func (c *Client) NVMeoFPortSubsysFindBySubsystem(ctx context.Context, subsysID int) (bool, error) {
	assocs, err := c.NVMeoFPortSubsysListBySubsystem(ctx, subsysID)
	if err != nil {
		return false, err
	}
	return len(assocs) > 0, nil
}

// NVMeoFPortSubsys represents a port-subsystem association from the TrueNAS API.
type NVMeoFPortSubsys struct {
	ID       int `json:"id"`
	PortID   int
	SubsysID int
}

// NVMeoFPortSubsysListBySubsystem returns all port-subsystem associations for a given subsystem.
// Note: TrueNAS 25.10+ API doesn't support filtering by nested fields (subsys.id),
// so we fetch all associations and filter client-side.
func (c *Client) NVMeoFPortSubsysListBySubsystem(ctx context.Context, subsysID int) ([]*NVMeoFPortSubsys, error) {
	// Fetch all port-subsystem associations (no filter - API doesn't support nested field filtering)
	result, err := c.Call(ctx, "nvmet.port_subsys.query", []interface{}{}, map[string]interface{}{})
	if err != nil {
		return nil, fmt.Errorf("failed to query port-subsystem associations: %w", err)
	}

	items, ok := result.([]interface{})
	if !ok {
		return nil, nil
	}

	// Filter client-side by subsystem ID
	assocs := make([]*NVMeoFPortSubsys, 0)
	for _, item := range items {
		if m, ok := item.(map[string]interface{}); ok {
			// Extract subsystem ID from nested structure
			var itemSubsysID int
			if subsys, ok := m["subsys"].(map[string]interface{}); ok {
				if id, ok := subsys["id"].(float64); ok {
					itemSubsysID = int(id)
				}
			}
			// Only include if it matches the requested subsystem ID
			if itemSubsysID != subsysID {
				continue
			}

			assoc := &NVMeoFPortSubsys{}
			if id, ok := m["id"].(float64); ok {
				assoc.ID = int(id)
			}
			if port, ok := m["port"].(map[string]interface{}); ok {
				if id, ok := port["id"].(float64); ok {
					assoc.PortID = int(id)
				}
			}
			assoc.SubsysID = itemSubsysID
			assocs = append(assocs, assoc)
		}
	}

	return assocs, nil
}

// NVMeoFPortSubsysDelete deletes a port-subsystem association by ID.
func (c *Client) NVMeoFPortSubsysDelete(ctx context.Context, id int) error {
	_, err := c.Call(ctx, "nvmet.port_subsys.delete", id)
	if err != nil {
		if strings.Contains(err.Error(), "does not exist") ||
			strings.Contains(err.Error(), "not found") {
			return nil
		}
		return fmt.Errorf("failed to delete port-subsystem association: %w", err)
	}
	return nil
}

// NVMeoFSubsystemList lists all NVMe-oF subsystems.
func (c *Client) NVMeoFSubsystemList(ctx context.Context) ([]*NVMeoFSubsystem, error) {
	result, err := c.Call(ctx, "nvmet.subsys.query", []interface{}{}, map[string]interface{}{})
	if err != nil {
		return nil, fmt.Errorf("failed to list NVMe-oF subsystems: %w", err)
	}

	items, ok := result.([]interface{})
	if !ok {
		return nil, fmt.Errorf("unexpected response format")
	}

	subsystems := make([]*NVMeoFSubsystem, 0, len(items))
	for _, item := range items {
		subsys, err := parseNVMeoFSubsystem(item)
		if err != nil {
			continue
		}
		subsystems = append(subsystems, subsys)
	}

	return subsystems, nil
}

// NVMeoFGetOrCreatePort finds an existing port or creates a new one.
// This is a convenience function for the CSI driver.
// If address is a hostname, it will be resolved to an IP address since
// TrueNAS API requires IP addresses for addr_traddr.
//
// Important: If a wildcard port (0.0.0.0) exists on the same service port,
// it will be reused since it binds to all interfaces and catches all traffic.
func (c *Client) NVMeoFGetOrCreatePort(ctx context.Context, transport string, address string, port int) (*NVMeoFPort, error) {
	// Resolve hostname to IP if needed (TrueNAS API requires IP addresses)
	resolvedAddr, err := resolveToIP(address)
	if err != nil {
		return nil, fmt.Errorf("failed to resolve address %q: %w", address, err)
	}

	// Try to find existing port with exact address first
	existingPort, err := c.NVMeoFPortFindByAddress(ctx, transport, resolvedAddr, port)
	if err != nil {
		return nil, err
	}
	if existingPort != nil {
		return existingPort, nil
	}

	// Check for a wildcard (0.0.0.0) port on the same service port.
	// A wildcard port binds to ALL interfaces, so traffic to any IP will hit it.
	// We must reuse it rather than creating a new specific IP port.
	if resolvedAddr != "0.0.0.0" {
		wildcardPort, err := c.NVMeoFPortFindByAddress(ctx, transport, "0.0.0.0", port)
		if err != nil {
			return nil, err
		}
		if wildcardPort != nil {
			return wildcardPort, nil
		}
	}

	// Create new port (addr_adrfam is auto-detected by TrueNAS)
	return c.NVMeoFPortCreate(ctx, transport, resolvedAddr, port)
}

// resolveToIP resolves a hostname to an IP address.
// If the input is already an IP address, it is returned as-is.
func resolveToIP(address string) (string, error) {
	// Check if it's already an IP address
	if ip := net.ParseIP(address); ip != nil {
		return address, nil
	}

	// Resolve hostname
	ips, err := net.LookupIP(address)
	if err != nil {
		return "", err
	}
	if len(ips) == 0 {
		return "", fmt.Errorf("no IP addresses found for %s", address)
	}

	// Prefer IPv4 addresses
	for _, ip := range ips {
		if ip4 := ip.To4(); ip4 != nil {
			return ip4.String(), nil
		}
	}

	// Fall back to first address (IPv6)
	return ips[0].String(), nil
}

// NVMeoFGetTransportAddresses gets available transport addresses for a transport type.
// Updated for TrueNAS SCALE 25.10+: expects array parameter with uppercase transport type.
// Returns a map of address -> address (for compatibility, we return just the keys as a slice).
func (c *Client) NVMeoFGetTransportAddresses(ctx context.Context, transport string) ([]string, error) {
	// 25.10+ expects uppercase transport type in an array
	upperTransport := strings.ToUpper(transport)
	result, err := c.Call(ctx, "nvmet.port.transport_address_choices", []string{upperTransport})
	if err != nil {
		return nil, fmt.Errorf("failed to get transport addresses: %w", err)
	}

	// 25.10+ returns a map[string]string instead of []string
	addresses := make([]string, 0)
	switch v := result.(type) {
	case map[string]interface{}:
		for addr := range v {
			addresses = append(addresses, addr)
		}
	case []interface{}:
		// Fallback for older API versions
		for _, addr := range v {
			if s, ok := addr.(string); ok {
				addresses = append(addresses, s)
			}
		}
	default:
		return nil, fmt.Errorf("unexpected response format: %T", result)
	}

	return addresses, nil
}

// parseNVMeoFSubsystem converts raw API response to NVMeoFSubsystem.
// Updated for TrueNAS SCALE 25.10+: reads "subnqn" instead of "nqn", adds "name" and "ports".
func parseNVMeoFSubsystem(data interface{}) (*NVMeoFSubsystem, error) {
	m, ok := data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("unexpected NVMe-oF subsystem format")
	}

	subsys := &NVMeoFSubsystem{}

	if v, ok := m["id"].(float64); ok {
		subsys.ID = int(v)
	}
	// 25.10+: "name" is the human-readable name
	if v, ok := m["name"].(string); ok {
		subsys.Name = v
	}
	// 25.10+: "subnqn" is the NQN (was "nqn" pre-25.10)
	if v, ok := m["subnqn"].(string); ok {
		subsys.NQN = v
	}
	if v, ok := m["serial"].(string); ok {
		subsys.Serial = v
	}
	if v, ok := m["allow_any_host"].(bool); ok {
		subsys.AllowAnyHost = v
	}
	// 25.10+: hosts is now an array of IDs (integers), not NQN strings
	if hosts, ok := m["hosts"].([]interface{}); ok {
		for _, h := range hosts {
			if id, ok := h.(float64); ok {
				subsys.Hosts = append(subsys.Hosts, int(id))
			}
		}
	}
	if namespaces, ok := m["namespaces"].([]interface{}); ok {
		for _, n := range namespaces {
			if id, ok := n.(float64); ok {
				subsys.Namespaces = append(subsys.Namespaces, int(id))
			}
		}
	}
	// 25.10+: ports array
	if ports, ok := m["ports"].([]interface{}); ok {
		for _, p := range ports {
			if id, ok := p.(float64); ok {
				subsys.Ports = append(subsys.Ports, int(id))
			}
		}
	}

	return subsys, nil
}

// parseNVMeoFNamespace converts raw API response to NVMeoFNamespace.
// Updated for TrueNAS SCALE 25.10+: "subsys" is now an object, adds device_type, device_uuid, etc.
func parseNVMeoFNamespace(data interface{}) (*NVMeoFNamespace, error) {
	m, ok := data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("unexpected NVMe-oF namespace format")
	}

	ns := &NVMeoFNamespace{}

	if v, ok := m["id"].(float64); ok {
		ns.ID = int(v)
	}
	// 25.10+: "subsys" is an object containing the full subsystem, extract the ID
	if subsys, ok := m["subsys"].(map[string]interface{}); ok {
		if id, ok := subsys["id"].(float64); ok {
			ns.SubsystemID = int(id)
		}
	}
	if v, ok := m["nsid"].(float64); ok {
		ns.NSID = int(v)
	}
	// 25.10+: device_type is a new field ("ZVOL" or "FILE")
	if v, ok := m["device_type"].(string); ok {
		ns.DeviceType = v
	}
	if v, ok := m["device_path"].(string); ok {
		ns.DevicePath = v
	}
	// 25.10+: new fields
	if v, ok := m["device_uuid"].(string); ok {
		ns.DeviceUUID = v
	}
	if v, ok := m["device_nguid"].(string); ok {
		ns.DeviceNGUID = v
	}
	if v, ok := m["enabled"].(bool); ok {
		ns.Enabled = v
	}
	if v, ok := m["locked"].(bool); ok {
		ns.Locked = v
	}

	return ns, nil
}

// parseNVMeoFPort converts raw API response to NVMeoFPort.
// Updated for TrueNAS SCALE 25.10+: "transport" is now "addr_trtype", adds index, addr_adrfam, enabled.
func parseNVMeoFPort(data interface{}) (*NVMeoFPort, error) {
	m, ok := data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("unexpected NVMe-oF port format")
	}

	port := &NVMeoFPort{}

	if v, ok := m["id"].(float64); ok {
		port.ID = int(v)
	}
	// 25.10+: index field
	if v, ok := m["index"].(float64); ok {
		port.Index = int(v)
	}
	// 25.10+: "addr_trtype" instead of "transport"
	if v, ok := m["addr_trtype"].(string); ok {
		port.Transport = v
	}
	if v, ok := m["addr_traddr"].(string); ok {
		port.Address = v
	}
	if v, ok := m["addr_trsvcid"].(float64); ok {
		port.Port = int(v)
	}
	// 25.10+: address family
	if v, ok := m["addr_adrfam"].(string); ok {
		port.AddrFamily = v
	}
	// 25.10+: enabled flag
	if v, ok := m["enabled"].(bool); ok {
		port.Enabled = v
	}
	if subsystems, ok := m["subsystems"].([]interface{}); ok {
		for _, s := range subsystems {
			if id, ok := s.(float64); ok {
				port.Subsystems = append(port.Subsystems, int(id))
			}
		}
	}

	return port, nil
}
